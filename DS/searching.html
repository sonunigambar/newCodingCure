<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Searching</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

</head>
<body>

    <div id="include-index"></div>

    <!-- Navigation fetch -->
    <script>
        fetch('../codingcure.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('include-index').innerHTML = data;
            });
    </script>
 <!-- Scroll to Top Button (initially hidden) -->
 <button id="scrollToTopBtn" class="btn btn-primary rounded-circle position-fixed" title="Go to top" style="bottom: 20px; right: 20px; display: none;">
    <i class="fas fa-arrow-up"></i>
</button>
    <!-- Main Content -->
    
    <div class="container my-4">
        <ul class="list-unstyled">
            <li class="mb-3"><i class="fas fa-check-circle text-primary"></i><a href="#linear_search">Liner Search</a></li>
            <li class="mb-3"><i class="fas fa-check-circle text-primary"></i><a href="#binary_search">Binary Search</a>
                <ul>
                    <li><a href="#binary_search_using_while_loop">Binary Search Using While Loop</a></li>
                    <li><a href="#binary_search_using_recursion">Binary Search Using Recursion</a></li>
                </ul>
            </li>
        </ul>
        <h2 id="linear_search">Understanding Linear Search</h2>

<p>Linear search is a simple searching technique where you go through each item in a list one by one until you find what you're looking for.</p>

<h2>What is Linear Search?</h2>

<p>Imagine you have a row of boxes, and you’re looking for a specific toy inside one of them. You start at the first box, open it, check if the toy is there, and if not, you move to the next box. You keep doing this one by one until you find the toy or reach the end of the row.</p>

<p>That's what a linear search does. It checks each item in a list one by one until it finds what it’s looking for. If it finds the item, it stops and tells you where it is. If it reaches the end without finding it, it says the item isn’t there.</p>

<h2>Key Points</h2>
<ul>
    <li><strong>Simple but Slow</strong>: It’s a straightforward way to search, but it can be slow for large lists because it checks each item individually.</li>
    <li><strong>Works for Any List</strong>: Linear search doesn’t require the list to be sorted, so it works on any type of list or array.</li>
</ul>

<p>Here’s the Java code again, with explanations to make it simpler:</p>
<pre>
<code>
public class LinearSearch {<br>
    &nbsp;&nbsp;// Method to perform linear search<br>
    &nbsp;&nbsp;public static int linearSearch(int[] arr, int target) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Go through each element in the array<br>
        &nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; arr.length; i++) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check if this element is the target<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arr[i] == target) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i;  // Return the position (index) if found<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return -1;  // If we go through everything and don't find it, return -1<br>
    &nbsp;&nbsp;}<br><br>
    &nbsp;&nbsp;public static void main(String[] args) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;int[] arr = {3, 5, 2, 7, 4, 9, 1};  // Array to search in<br>
        &nbsp;&nbsp;&nbsp;&nbsp;int target = 7;  // The number we're looking for<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;int result = linearSearch(arr, target);  // Call the search method<br><br>
        &nbsp;&nbsp;&nbsp;&nbsp;if (result != -1) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Element found at index: " + result);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Element not found in the array.");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    &nbsp;&nbsp;}<br>
}<br>
</code>
</pre>
<h2>Time and Space Complexity of Linear Search</h2>

<h3>1. Time Complexity</h3>

<p>In linear search, we iterate through each element of the array one by one to find the target value. Let's denote:</p>
<ul>
    <li><strong>n</strong>: the number of elements in the array.</li>
</ul>

<h4>Best Case: <code>O(1)</code></h4>
<p>If the target is found at the first position (index <code>0</code>), the search stops immediately. This requires only one comparison, making the time complexity <code>O(1)</code>.</p>

<h4>Worst Case: <code>O(n)</code></h4>
<p>If the target is found at the last position or is not in the array at all, we need to check every element. This requires <code>n</code> comparisons, making the time complexity <code>O(n)</code>.</p>

<h4>Average Case: <code>O(n)</code></h4>
<p>In the average case, the target is expected to be found around the middle of the array, after checking about <code>n/2</code> elements. However, in Big-O notation, we drop constants, so the average case is also <code>O(n)</code>.</p>

<p><strong>Overall Time Complexity:</strong> <code>O(n)</code></p>

<h3>2. Space Complexity</h3>

<p>Linear search only requires a small, fixed amount of space:</p>
<ul>
    <li>It uses a variable to store the index of each element during iteration.</li>
    <li>The input array is not modified or duplicated, so no extra space is needed.</li>
</ul>

<p>Since the amount of memory used does not grow with the size of the input, the <strong>space complexity</strong> is:</p>

<p><strong>Space Complexity:</strong> <code>O(1)</code></p>

<h3>Summary</h3>
<ul>
    <li><strong>Time Complexity:</strong> <code>O(n)</code></li>
    <li><strong>Space Complexity:</strong> <code>O(1)</code></li>
</ul>

<h2 id="binary_search">Binary Search Explained</h2>

<p>Binary search is a method to quickly find a specific item in a <strong>sorted list</strong> by repeatedly dividing the list into two halves.</p>

<h2>Understanding Binary Search</h2>
<p>Imagine a dictionary. If you want to find the word "apple," you wouldn’t start on the first page and go through each word one by one (that would be a linear search). Instead, you’d open the dictionary roughly in the middle, check if "apple" is on that page, and if not, decide whether to go to the first half or the second half.</p>

<h2>Steps to Perform Binary Search</h2>
<ol>
    <li><strong>Start with the middle:</strong> Check the middle item of the list.</li>
    <li><strong>Compare with the target:</strong>
        <ul>
            <li>If the middle item is what you’re looking for, you’ve found it!</li>
            <li>If the middle item is <strong>too big</strong>, that means the target must be in the first half, so ignore the second half.</li>
            <li>If the middle item is <strong>too small</strong>, the target must be in the second half, so ignore the first half.</li>
        </ul>
    </li>
    <li><strong>Repeat the process</strong> on the remaining half until you find the item or there are no items left to check.</li>
</ol>

<h2>Why Binary Search is Fast</h2>
<p>Because binary search eliminates half of the remaining items each time, it finds the target very quickly, even in large lists. It’s much faster than checking each item one by one.</p>

<h2 id="binary_search_using_while_loop">Binary Search Example Code in Java</h2>
<pre><code>
public class BinarySearchExample {
public static int binarySearch(int[] arr, int target) {
    int low = 0;                // Start at the beginning
    int high = arr.length - 1;   // End at the last item

    while (low <= high) { 
        int mid = low + (high - low) / 2; // Find the middle item
        
        if (arr[mid] == target) {         // Found the target!
            return mid;
        }
        else if (arr[mid] < target) {     // Target is in the right half
            low = mid + 1;
        }
        else {                            // Target is in the left half
            high = mid - 1;
        }
    }
    return -1; // If we reach here, the target isn't in the list
}

public static void main(String[] args) {
    int[] sortedArray = {1, 3, 5, 7, 9, 11, 13}; // Array must be sorted
    int target = 7;

    int result = binarySearch(sortedArray, target);

    if (result == -1) {
        System.out.println("Element not found in the array.");
    } else {
        System.out.println("Element found at index: " + result);
    }
}
}
</code></pre>

<h2>Understanding Time Complexity and Space Complexity</h2>

    <h3>Time Complexity</h3>
    <p><strong>Time complexity</strong> measures how the execution time of an algorithm grows relative to the input size. It gives an estimate of the amount of time an algorithm will take to run based on the size of the input data.</p>

    <h3>Common Time Complexity Notations:</h3>
    <ul>
        <li><code>O(1)</code>: Constant time — the execution time does not change regardless of input size. (e.g., accessing an element in an array)</li>
        <li><code>O(log n)</code>: Logarithmic time — the execution time grows logarithmically as the input size increases. (e.g., binary search)</li>
        <li><code>O(n)</code>: Linear time — the execution time grows linearly with the input size. (e.g., linear search)</li>
        <li><code>O(n log n)</code>: Linearithmic time — often seen in efficient sorting algorithms like mergesort and heapsort.</li>
        <li><code>O(n²)</code>: Quadratic time — the execution time grows quadratically with the input size, often seen in algorithms with nested loops (e.g., bubble sort).</li>
        <li><code>O(2^n)</code>: Exponential time — the execution time doubles with each addition to the input size. (e.g., certain recursive algorithms)</li>
        <li><code>O(n!)</code>: Factorial time — grows very rapidly and is seen in problems that involve permutations (e.g., the traveling salesman problem).</li>
    </ul>

    <h3>Example</h3>
    <p>For a linear search in an array of size <code>n</code>:</p>
    <ul>
        <li>In the worst case, you might have to check every element, leading to a time complexity of <code>O(n)</code>.</li>
    </ul>

    <h3>Space Complexity</h3>
    <p><strong>Space complexity</strong> measures how much memory an algorithm needs relative to the input size. It takes into account both the temporary space allocated by the algorithm and the space required for input values.</p>

    <h3>Common Space Complexity Notations:</h3>
    <ul>
        <li><code>O(1)</code>: Constant space — the algorithm uses a fixed amount of space regardless of input size.</li>
        <li><code>O(n)</code>: Linear space — the space required grows linearly with the input size.</li>
        <li><code>O(n²)</code>: Quadratic space — the space required grows quadratically, often seen in algorithms that create a 2D matrix.</li>
    </ul>

 <h2 id="binary_search_using_recursion">Binary Search Code Using Recursion</h2>
 <pre>
    <code>
        public class BinarySearch {

            // Recursive binary search function
            public static int binarySearch(int[] arr, int target, int left, int right) {
                // Base case: if the range is invalid
                if (left > right) {
                    return -1; // Element is not found
                }
        
                // Find the middle index
                int mid = left + (right - left) / 2;
        
                // Check if the target is at mid
                if (arr[mid] == target) {
                    return mid; // Element found at index mid
                }
        
                // If target is smaller, search in the left half
                if (target < arr[mid]) {
                    return binarySearch(arr, target, left, mid - 1);
                }
        
                // If target is larger, search in the right half
                return binarySearch(arr, target, mid + 1, right);
            }
        
            public static void main(String[] args) {
                int[] sortedArray = {2, 3, 4, 10, 40, 50};
                int target = 10;
        
                int result = binarySearch(sortedArray, target, 0, sortedArray.length - 1);
        
                if (result == -1) {
                    System.out.println("Element not found in the array.");
                } else {
                    System.out.println("Element found at index: " + result);
                }
            }
        }
        
    </code>
 </pre>
    </div>

   

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../scrollTop.js"></script>
</body>
</html>
